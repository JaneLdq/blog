---
title: 浅谈网络安全（一）- 保密性与加密机制
date: 2020-04-07 10:48:44
categories: 技术笔记
tags:
- 网络安全
- 对称密钥加密
- 非对称密钥加密
---

网络安全这个话题实在太庞大了，小到单个资源的访问控制、通信内容的防窃听与防篡改，大到对组织整体网络 DDoS 攻击的防控，都属于网络安全的范畴。如果要对这些具体的操作详细说明，那么每个都可以单独拿出来写出长篇大论，而作为一篇入门向笔记，我们还是从最简单的场景开始吧。

现在疫情这么严重，大家很多都是在家办公，每天只能通过网络交流工作，我们自然希望 1）通信内容是保密的，不会在传输过程中被他人窃取；2）消息都是完好的，没有被篡改过的；3）我们还得确认网线对面确实是我们的同事，而不是假冒的。如果做不到这些，那我们的工作内容很容易就会泄漏出去，如果是十分重要的内容，必定会对公司造成巨大损失。简单归纳以上几点，我们可以得出安全的网络通信得具备如下几个特性：
* **保密性 (Confidentiality)** - 需要某种机制对通信内容加密
* **报文完整性 (Message integrity)** - 能够检测出消息是否完整，是否在传输中被恶意篡改或伪造
* **身份认证 (End-point Authentication)** - 通信的双方能互相验证身份

在网络安全中，密码学扮演了至关重要的角色。通过加密，我们很自然地就获得了通信的保密性。
<!--more-->
---
# 密码学基础知识
首先，我们简单了解一下几点基础的密码学知识吧。

通常，我们可以将一个加密系统表示为一个五元组：
* **明文** (**P**laintext) - 加密前的原始消息
* **密文** (**C**iphertext, C)- 经过加密之后得到的结果
* **加密算法** (**E**ncryption algorithm) - 将明文转为密文的运算
* **解密算法** (**D**ecryption algorithm) - 将密文还原为明文的运算
* **密钥** (**K**ey) - 一串数字或字母，在进行加密/解密计算时作为参数输入。同一个明文在相同的密码算法和不同的密钥计算下会产生不同的密文。密钥的长度通常决定了密文的安全性。

以五元组 `(P, C, E, D, K)` 可以将加密解密的过程表示为如下公式, 其中 E<sub>K</sub> 表示以密钥 K 进行加密，D<sub>K</sub> 表示以密钥 K 进行解密：$$C=E_{K}(P), \, D_{K}(C)=P$$

---
## 三类密码分析场景
* **Ciphertext Only** - 分析者只有密文，没有对应的明文
* **Known Plaintext** - 分析者有部分相匹配的密文和明文（已知部分明文与密文的映射关系）
* **Chose Plaintext** - 分析者能够加密某些他/她自己选择的明文（已知部分明文的加密过程）

---
## 两类传统密码学加密方式
### 置换密码
置换密码(sustitution cipher)，将明文中**每个字母或者每组字母替换为另一个字母或另一组字母**。

最古老也是最经典的例子即**凯撒密码 (Caesar cipher)** - 每个字母按字母序移动 3 个位置。
* 凯撒密码一般化：按照字母序移动 k 个位置，**26** 种可能性
* 凯撒密码改进版：让每个字母映射为另一个字母，**26!** 种可能性

像这种一一对应的置换策略被成为**单字母置换**。针对这种加密方式的基本攻击手段是**利用自然语言的统计特性，计算所有字母在密文中的出现频率，与自然语言中字母的出现频率相比较，逐个试探映射关系**。除此之外，综合常见的两字母组合、三字母组合，比如 `th`, `er`, `the`, `and` 等。
下图为26个字母的频率分布（图来自 [Letter Frequency - Wikipedia](https://en.wikipedia.org/wiki/Letter_frequency)），可以看到 `e` 为最常见的字母，`t` 次之。根据这些特性，在分析一段密文时，我们可以猜测出现频率最高的字母置换的就是 `e`，次之为 `t`。接下来，若看到常见的 `tXe` 组合，那么可以合理推测 `X` 置换的是 `h`。通过一系列的猜测，可以逐渐试探出明文。
![Letter frequency][1]

### 移位密码
移位密码 (transposition cipher)，**将明文中的字母重新排列，本身不变，只是位置变了**。
一种常见的移位密码方案为**列换位**。列换位使用一个不包含重复字母的单词或短语作为密钥，假设密钥长度为 L, 明文长度为 N，则将明文以每行长度为 L 进行排列，得到 N 列字符串。密文则按密钥字母最小的那列开始按列输出。
举个例子，假设我们以 `HIWORLD` 作为密钥来加密 `phpisthebestlanguageintheworld` 这段明文：
```
H I W O R L D
2 3 7 5 6 4 1
-------------
p h p i s t h
e b e s t l a 
n g u a g e i 
n t h e w o r 
l d
```
如上所示，按字母序 `D H I L O R W` 逐个输出每一列得到密文 `hairpennlhbgtdtleoisaestgwpeuh`。
在移位密码中，每个字母都代表自己，因此通过分析密文中的字母出现的频率分布就可以判断加密方式是否为移位加密。至于移位密码的破解，我也没有详细研究，就不多提了。

---
## 两个基本密码学原则
1. **消息必须包含一定的冗余度**，用来阻止侵入者发送随机垃圾信息诱骗接收方解密消息并将其解释为有效内容造成破坏。
2. **需要采取某种方法对抗重放攻击**。

---

在密码学中有个 Kerckhoff's principle — **所有的算法必须是公开的，而密钥是保密的**。现代密码学的目标即是使加密算法尽可能的复杂，使分析者即使拿到了大量选择密文，若没有密钥，也不能推测出明文。

根据密钥的类型，我们可以将现代加密算法分为两大类：**对称密钥加密**和**非对称（公开）密钥加密**，我们将在下文依次介绍。

---
# 对称密钥加密
对称密钥加密是指**加密和解密使用相同的密钥**。
对称密钥加密主可分为两类：
* **分组密码 (block cipher)** ，被广泛应用在多个 Internet 安全协议中，比如 PGP (用于 e-mail)，SSL (用于 TCP )，IPsec (用于网络层)
* **流密码 (stream cipher)**，应用在无线局域网

## 分组密码
分组密码**将一段长度为 n 位的明文与长度为 k 位的密钥作为输入进行加密，明文被分割为长度为 k 位的块 (block) 被加密为长度同为 k 位的密文，最终输出长度为 n 位的密文**。

那么，如何实现分组密码呢？

一种最容易想到的方式就是建立一个映射表，假设块大小为 k 位，我们为每个可能的 k 位明文块映射到一个对应的 k 位密文块。加密和解密双方都拥有一份这个映射表，用来加/解密，映射表一共有 **2<sub>k</sub>!** 个可选排列（全排列）。然而，这种方式在实践中几乎是不可行的，一个 k 位大小的块对应的映射表的大小是 **2<sup>k</sub>** 条记录，无论是存储、查询还是更换都难实现。

所以，现在实际应用的块加密算法大多采用函数来模拟随机排列的映射表。常见的加密算法有[**DES**](https://en.wikipedia.org/wiki/Data_Encryption_Standard) (Data Encryption Standard，太脆弱，现在已经不用了)，[**3DES**](https://en.wikipedia.org/wiki/Triple_DES) (Triple DES)，[**AES**](https://en.wikipedia.org/wiki/Advanced_Encryption_Standard) (Advanced Encryption Standard, 目前最好的选择)等。 

### 密码模式
由于分组密码的本质是一种单字母置换密码算法（每个字母对应一个二进制串，每个二进制串被映射为一个唯一的替换二进制串），那么当使用相同的明文，相同的密钥作为输入时，总会得到相同的密文，因此较长的明文中的某些特征或者模式 (pattern) 会体现在密文中，这点很容易被破解者利用。

那么，当明文的长度由多个块组成时，要如何应用分组密码加密才能避免上述弱点呢？这个时候，就需要提到**分组密码操作模式(Block cipher mode of operation)**了。

常见的密码模式有如下几种：
* **ECB (Electronic codebook)**
* **CBC (Cipher block chaining)**
* **CFB (Cipher feedback)**
* **OFB (Output feedback)**
* **CTR (Counter)**

一种最基本的思想是在加密过程中引入随机数以消除重复模式，不过各个密码模式在这里就不详细介绍了，详情请戳 [Block cipher mode of operations - Wiki](https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation)。（先挖个坑，以后有时间可能再单独开篇笔记写吧）


<!--
## 流密码
-->

密钥如此重要，而使用对称密钥加密通信要求通信双方都拥有相同的密钥，那么问题来了，如何安全地分发密钥呢？如果密钥在分发过程中被盗取，那么由于加密解密用的是相同的密钥，整个加密就失去了意义。

好在，我们还有非对称密钥加密。

--- 
# 非对称密钥加密
非对称密钥加密，又称为公开密钥加密，它采用一组**密钥对**来实现加密解密过程，其中一把密钥是公开的，一把是用户私有的，在加密和解密过程中采用不同的密钥进行操作：
* 当 Alice 给 Bob 发送加密消息时，采用 Bob 的公钥进行加密
* 当 Bob 收到加密消息时，采用自己的私钥进行解密

> 题外话：Alice 和 Bob 是密码学届非常有名的角色了，我们之后也沿用这一传统，用他们来代表通信双方

$$C=E_{K_{public}}(P), \, D_{K_{private}}(C)=P$$

因为公钥本身就是公开的，因此不用担心密钥在分发过程中被盗取。但是，公开密钥加密算法的应用还需要考虑如下问题：
* **要能应对选择明文攻击** - 由于用来加密的算法是公开的，入侵者可以猜测某些 Alice 可能发给 Bob 的消息（选择明文）并用 Bob 的公钥加密然后发给 Bob。
* **要能够认证发消息的人确实是声明者本人** - 关于这一点，见后文**数字签名**。

## RSA
目前最常用的非对称密钥加密算法是 [**RSA**](https://en.wikipedia.org/wiki/RSA_(cryptosystem%29)。RSA 基于数论的一些原理，具体的我也不是很清楚，就不瞎说了，详情请见相关论文。其**安全性建立在大数分解的难度基础之上**。

---

到此为止，我们介绍了一些密码学的基本知识，和两种加密机制：对称密钥加密和非对称密钥加密。在网络中，这两种加密机制经常组合使用以提供安全的通信，在接下来要介绍报文完整性与数字签名以及身份认证的笔记中我们还会多次见到它们的身影。

---

**参考资料**
* 计算机网络，第五版
* Computer Networking: A Top-Down Approach, 7th Edition
* [Block cipher - Wiki](https://en.wikipedia.org/wiki/Block_cipher)
* [Block cipher mode of operations - Wiki](https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation)

[1]:/uploads/images/letter_freq.svg


